

## 在不支持js的浏览器中，html内嵌js p16


```javascript
<script><!--
	function sayHi(){
		alert(2)
	}
// --> </script>
```

## 严格模式

```
IE 10+
fireFox 4+
safari 5.1+
Opera 12+
chrome
```

TODO : 8如何开启？

## 始终执行代码块
```
if(test) console.log(1);  // 可以执行但是不好
if(test){console.log(1)};  // 好
```

## var声明变量仅在代码块中有效

```javascript
function test(){
	var message = 'hi'; //局部变量
}
test();
alert(message); // 错误！
```
```
function test(){
	message = 'hi';
}
test();
alert(message);
```

## 基础类型和 typeof
```js
6大基础类型： Number String Boolean Object Undefined Null (原始类型是 去掉Object 的五种)
typeof 返回值-7种： Number String Boolean Object Undefined Null Function(基础类型中属于Object))
```

### 数据类型
1. null
> null值表示一个空对象指针,所以 typeof null 会返回一个 'object'

同时 null的含义也代表不存在-- `Object.prototype.__proto__`, 如果代表存在，但是未定义的话  应该用`undefined`,
> 当然如果想要定义一个变量将来用来保存对象，可以直接将其赋值为`null`,这样可以用 `xx !== null`来判断是否执行后续的操作。

2. Boolean
数字类型里的 `0`和`NaN`会转换成 `false`

3. Number
> 由于保存浮点数值需要的内存空间是保存整数值的两倍,因此 ES会不失时机的将浮点数转换成整数
```js
var a = 10.0;
a === 10;// true
```
> 关于浮点数值计算会产生舍入误差的问题，有一点需要明确:这是使用基于IEEE754数值的浮点计算的通病。 `0.1 + 0.2 // 0.30000000000000004`
> 在进行极大极小值计算时，要避免触碰到js的最大最小值. `Number.MAX_VALUE; // 1.7976931348623157e+308` 和 `Number.MIN_VALUE; // 5e-324`

4. String
> 可以用toString()方法来将其他类型的值转换成str类型(null 和 undefined不行). 同时 str也有toSting()方法，来生成一个副本。

5. Object 几个方法
* hasOwnProperty 查看某个属性是否在当前对象实例中(而不是在原型里)
* isPrototypeOf 用于检查传入的对象是否是另一个对象的原型
* propertyIsEnumerable(propertyName) 用于判断给定的属性能否用 for-in语句来枚举
* toLocal

### 数据转换
#### Object 转 String
```js
var obj={name:'Mofei'}
var str = ' ' + obj
console.log(str);  //   [object Object]
```
> 上述的例子中，在字符串相加的过程中，系统调用了obj的String转换，具体规则如下：

> 如果toString方法存在并且返回“原始类型”，返回toString的结果。<br>
> 如果toString方法不存在或者返回的不是“原始类型”，调用valueOf方法，如果valueOf方法存在，并且返回“原始类型”数据，返回valueOf的结果。<br>
> 其他情况，抛出错误。
```js
var a={
    toString:function(){
        console.log('调用了 a.toString');
        return '111';
    }
}
alert(a);

//调用了 a.toString
// 111
```
增加valueOf方法
```js
var a={
    toString:function(){
        console.log('调用了 a.toString');
        return '111';
    },
    valueOf:function(){
        console.log('调用了 a.valueOf');
        return '111';
    }
}
alert(a);

//调用了 a.toString
// 111
```
将toString返回改成非 原始类型
```js
var a={
    toString:function(){
        console.log('调用了 a.toString');
        return {};
    },
    valueOf:function(){
        console.log('调用了 a.valueOf');
        return '111';
    }
}
alert(a);

// 调用了 a.toString
// 调用了 a.valueOf
// 111
```
将valueOf里的return 也改成 非 原始类型
```js
var a={
    toString:function(){
        console.log('调用了 a.toString');
        return {};
    },
    valueOf:function(){
        console.log('调用了 a.valueOf');
        return ()=>{};
    }
}
alert(a);

// 调用了 a.toString
// 调用了 a.valueOf

// VM463:11 Uncaught TypeError: Cannot convert object to primitive value
```
#### Object 转 Number
规则和转成String类似，不过先访问valueOf,不返回原始类型,则调用toString,还不行则Error
```js
var a={
    toString:function(){
        console.log('调用了 a.toString');
        return 12;
    },
    valueOf:function(){
        console.log('调用了 a.valueOf');
        return {};
    }
}
// 调用了 a.valueOf
// 调用了 a.toString
// 13
```

#### 练习题
```js
parseInt(0.0000004)  // 4
![]==[] //true
['x','y'] == 'x,y' //true
```

1. 
```js
parseInt(0.0000004);
parseInt(0.0000004.toString());
parseInt("4e-7"); // 4
```
2. 
```js
![] == []; // !优先级高
false == []; // 当"=="号两边其中一个是布尔值的话，先把它转换为数字（ECMAScript的规范）
0 == []; // 当"=="的一边是字符串或数字，另一边是对象的时候（数组也是对象），先把对象值转换为Number(先valueOf)或str(先toString)再判断相等
0 == [].valueOf(); // [].valueOf() 还是等于 [], 则执行 [].toString()
0 == [].toString(); // 0 == '', 当"=="两边一个是字符串一个是数字的时候，先把字符串转为数字，再进行比较
0 == Number('');
0 == 0// true
```
3. 
```js
['x', 'y'] == 'x,y'; // 当"=="的一边是字符串或数字，另一边是对象的时候（数组也是对象），先把对象值转换为Number(先valueOf)或str(先toString)再判断相等
['x', 'y'].toString() == 'x,y';
'x,y' == 'x,y'; //true
```