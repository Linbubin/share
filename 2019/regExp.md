# 正则表达式

## 匹配之前相同值
> \index 即可
```js
// 把a中按相同数字拆分出来
let a = '11122333';
a.match(/(\d)\1*/g)
```

## ? 加一个符号

### ?= 前瞻后顾
```
// 前瞻：
exp1(?=exp2) 查找exp2前面的exp1
// 后顾：
(?<=exp2)exp1 查找exp2后面的exp1
```

demo:
```js
"中国人".replace(/(?<=中国)人/, "rr") // 匹配中国人中的人，将其替换为rr，结果为 中国rr
"法国人".replace(/(?<=中国)人/, "rr") // 结果为 法国人，因为人前面不是中国，所以无法匹配到
"中国人".replace(/中国(?=人)/, "帅") // 匹配中国人中的中国，将其替换为帅，结果为 帅人
"法国人".replace(/中国(?=人)/, "帅") // 结果为 法国人，因为人前面不是中国，所以无法匹配到
```

### ?! 负前瞻 负后顾
```
// 负前瞻：
exp1(?!exp2) 查找后面不是exp2的exp1
// 负后顾：
(?<!exp2)exp1 查找前面不是exp2的exp1
```
demo:
```js
"中国人".replace(/中国(?!人)/, "帅") // 后面是人,所以匹配不到
"中国人".replace(/中国(?!好人)/, "帅") // 后面是好人,所以可以匹配,把中国替换成帅, 结果为  帅人
"中国人".replace(/(?<!中国)人/, "rr") // 前面使中国,所以匹配不到
"法国人".replace(/(?<!中国)人/, "rr") // 前面是法国,不是中国，可以匹配,把人换成rr, 结果为 法国rr
```

### ?: 非捕获分组
> ()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)<br>
> (?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来

demo:
```js
var a = a = '1234'
a.replace(/(?:\d{3})(\d{1,})/, '$1 123'); // "4 123"
```