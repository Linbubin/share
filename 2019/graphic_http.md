# 图解http读书记录

## 客户端
> 通过发送请求获取服务器资源的web浏览器等,称为客户端(client).

## TCP/IP
> 把互联网相关联的协议集合起来总称为TPC/IP.(比如电缆规格、IP地址的选定、寻找异地用户的方法、双方建立通信的顺序)<br>
> TCP/IP协议族按层次分别分为以下4层:
> * 应用层(HTTP, FTP, DNS)
> * 传输层(TPC)
> * 网络层(IP)
> * 数据链路层(处理网卡、光纤等硬件范畴)

TPC/IP协议族进行网络通信时,发送端从应用层往下走,接收端从链路层往上走.
> 拿HTTP举例说明,首先作为发送端的客户端在应用层(HTTP协议)发出一个想看某个Web页面的HTTP请求.<br>
> 为了传输方便,在传输层(TCP协议)会将应用层接收到的数据(HTTP请求报文)进行分割,并在各个报文上打上标记序号及端口号后转发给网络层.<br>
> 在网络层(IP协议),增加作为通信目的地的MAC地址后转发给链路层.<br>
> 接收端在链路层收到数据,按序往上层发送,一直到应用层.当传送到应用层,才能算真正接收到由客户端发送过来的HTTP请求.

封装过程
* 应用层 HTTP报文拿到HTTP数据
* 传输层 TCP报文段给HTTP数据套上 TCP首部
* 网络层 IP数据包给传输层的数据套上 IP首部
* 链路层 网络架构给网络层数据套上 以太网首部
* 反过来,从下到上,会依次拿掉首部,从而得到HTTP数据

### TCP
> TCP位于传输层,将大块数据分割以报文段为单位的数据包进行管理.<br>
> TCP协议为了更容易传送大数据才把数据分割,而且TCP协议能够确认数据最终是否送达到对方.
#### 三次握手
> TCP为了准确将数据送达目标处,采用`三次握手`策略
> 1. 发送端 SYN标记数据包 -> 接收端
> 2. 接收端 SYN/ACK数据包 -> 发送端
> 3. 发送端 ACK标记数据包 -> 接收端

### 各协议和HTTP协议的关系
客户端访问wuqiu.xyz服务器
1. 向DNS拿到IP地址
2. HTTP协议生成针对目标Web服务器的HTTP请求报文
3. TCP协议将HTTP请求报文分割成报文段
4. IP协议将报文段送到指定IP地址的位置
5. TCP将报文段按序号重组请求报文
6. HTTP协议对Web服务器请求的内容进行处理
7. 请求结果按TCP/IP通信协议向用户进行回传

### HTTP报文
> 用于HTTP协议交互的信息被称为HTTP报文.请求端的HTTP报文叫做请求报文,响应端的叫做响应报文.<br>
> HTTP报文大致可分为报文首部和报文主体两块.<br>
> HTTP报文首部包含请求行、状态行、首部字段.

#### 报文主体和实体主体的差异
* 报文 是HTTP通信中的基本单位,由8位组字节流组成,通过HTTP通信传输.
* 实体 作为请求或响应的有效载荷数据被传输,其内容由实体首部和实体主体组成.
* 当传输中进行编码操作时,实体主体的内容发生变化,才导致它和报文主体产生差异.

#### 传输过程
* 实体主体分块的功能称为分块传输编码.
* 恢复是指能从之前下载中断处恢复下载.范围请求-首部字段Range来指定资源的byte范围.针对范围请求,响应会返回状态码为206 Partial Content的响应报文.

#### 内容协商
> 访问相同的URI的Web页面时,则会显示对应的英语版或中文版的Web页面.

协商技术有以下三种类型
* 服务器驱动协商 以请求的首部为参考,在服务端自动处理.
* 客户端驱动协商 用户从浏览器显示的可选项列表中手动选择.
* 透明协商 由服务器+客户端

## URI和URL
> URI就是由某个协议方案(HTTP,FTP,FILE)表示的定位标识符.
> URI用字符串标识某一互联网资源,而URL表示资源的地点.可见URL是URI的子集

个人认为是URI有很多协议,而URL只是HTTP协议.

绝对URI格式

http://user:pass@www.wuqiu.xyz:80/index.html?uid=1#ch1
* http:// 为协议方案名
* user:pass 登录信息
* www.wuqiu.xyz 服务器地址
* 80 服务器端口号
* index.html 带层次的文件路径
* uid=1 查询字符串
* ch1片段标识符

## HTTP协议用户客户端和服务器端之间的通信
> 应用HTTP协议时,必定是一端担任客户端角色,另一端担任服务器端角色.<br>
> 协议规定先从客户端开始建立通信,服务器端在没有接收到请求之前不会发送响应.<br>
> HTTP是一种不保存状态,即无状态协议.但是为了实现期望的保持状态功能,引入了`Cookie`技术.<br>
> HTTP/1.1支持持久连接(TCP连接中途不断开)和管线化(并行发送多个请求,之前是一个请求结果返回后才能发送下个请求).

### 客户端
> 请求访问文本或图像等资源的一端称为客户端
### 服务器端
> 提供资源相应的一端称为服务器端
### 报文
客户端和服务器之间使用`报文`进行通信.
#### 请求报文
> 请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的.<br>
> POST /form/entry HTTP/1.1 其中`POST`为方法,`/form/entry`为URI,`HTTP/1.1`为协议版本
#### 响应报文
> 响应报文基本上由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成.
> HTTP/1.1 200 OK 其中`HTTP/1.1`为协议版本,`200`为状态码,`OK`为状态码的原因短语

### 告知服务器意图的HTTP方法
1. GET 获取资源,GET方法用来请求访问已被URI识别的资源.
2. POST 传输实体主体,POST的主要目的并不是获取响应的主体内容,更多用来告知服务器处理一些事务,比如数据库的增删改操作.
3. PUT 传输文件,但是鉴于HTTP/1.1的PUT方法自身不带验证机制,任何人都可以上传文件,存在安全问题,因此一般的Web网站不使用该方法.REST标准的Web网站可能会开放.
4. DELETE 删除文件,和3中PUT方法相对立,由于同样原因,一般不推荐.
5. HEAD 获取报文首部,HEAD方法和GET一样,只是不返回报文主体部分.用于确认URI的有效性及资源更新的日期时间等.
6. OPTIONS 询问支持方法,返回结果中带有服务器支持的方法,比如GET POST等.
7. TRACE 追踪路径,客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的.
8. CONNECT 要求用隧道协议连接代理,只要使用SSL,TLS协议把通信内容加密后经网络隧道传输.

### Cookie技术
> Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态.<br>
> Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息,通知客户端保存Cookie.当下次客户端再往该服务器发送请求时,客户端会**自动**在请求报文中加入Cookie值后发送出去.

## HTTP状态码
| 状态码   |      类别      |  原因短语 |
|----------|:-------------:|------:|
| 1xx |  信息性状态码 | 接收的请求正在处理 |
| 2xx |    成功状态码   |  请求正常处理完毕 |
| 3xx | 重定向状态码 | 需要进行附加操作以完成请求 |
| 4xx | 客户端错误状态码 | 服务器无法处理请求 |
| 5xx | 服务端错误状态码| 服务器处理请求出错 |
### 2xx
#### 200
* 请求正常处理
#### 204
* 返回内容中不包含实体的主体部分,即返回204响应浏览器显示页面不发生更新.
* 一般在只需要从客户端往服务器发送信息,而对客户端不需要发送新信息内容情况下使用.

#### 206
* 请求部分内容
* 响应报文中包含由 Content-Range 指定范围的实体内容.

### 3xx重定向
#### 301
* 永久性重定向 改状态吗表示请求资源已被分配了新的URI,以后应使用资源现在所指的URI.

#### 302
* 临时重定向 已移动的资源对应的URI将来还有可能发生改变.比如,用户吧URI保存成书签,但不会像301状态码出现时那样去更新书签,而是仍旧保留返回302状态码的页面对应的URI.

#### 303
* 和302有相同功能,但是明确表示客户端应当采用GET方法获取资源.

#### 304
* 服务器端允许请求返回资源,但因发生请求未满足条件的情况下,直接返回304 Not Modified.

#### 307
* 同302,但是307会遵照浏览器标准,不会从POST变成GET(大部分浏览器在处理重定向时会把POST改成GET).

### 4xx
#### 400
* 请求报文存在语法错误

#### 401
* 浏览器首次接收到401响应,会弹出认证用的对话窗口.

#### 403
* 对请求资源的访问被服务器拒绝了.

#### 404
* 服务器上无法找到请求的资源.

### 5xx
#### 500 
* 服务器端在执行请求时发生了错误.

#### 503
* 服务器暂时处于超负载或正在进行停机维护.

## 与HTTP协作的Web服务器
> 物理层面只有一台服务器,但只要使用虚拟主机的功能,则可以假想已具有多台服务器.<br>
> 由于虚拟主机可以寄存多个不同主机名和域名的Web网站,因此在发送HTTP请求时,必须在Host首部内完整指定主机名或域名的URI.<br>

### 通信数据转发程序: 代理、网关、隧道
#### 代理
> 代理是一种由转发功能的应用程序,它扮演了位于服务器和客户端"中间人"的角色.
* 转发时,需要附加Via首部字段以标记出经过的主机信息.
* 使用代理服务器的理由有:利用缓存技术减少网络贷款的流量,组织内部针对特定网站的访问控制,以获取访问日志为主要目的.
* 缓存代理: 代理转发响应时,会预先将资源的副本保存在代理服务器上,当代理服务器再次接收到对相同资源的请求时,就可以不从源服务器那里获取资源,而是将之前缓存的资源作为相应返回.
* 透明代理, 转发请求或响应时,不对报文做任何加工的代理类型被称为透明代理.(类似隧道)
#### 网关
> 网关是转发其他服务器通信数据的服务器,接收从客户端发送来的请求时,它就像自己拥有资源的原服务器一样对请求进行处理.
* 工作机制和代理相似,但是网关能使通信线路上的服务器提供非HTTP协议服务(与sql, 信用卡结算系统连接).
#### 隧道
> 隧道是在相隔甚远的客户端和服务器两者之间进行中转,并保持双方通信连接的应用程序.隧道不会对传输数据进行任何的处理.
#### 保存资源的缓存
> 缓存服务器是代理服务器的一种,并归类在缓存代理类型中.<br>
> 缓存有效期限和客户端的缓存都会由于某些原因过期,而重新向目的服务器发起请求.

## HTTP首部
> HTTP协议的请求和响应报文中必定包含HTTP首部.<br>
> HTTP请求报文由方法、URI、HTTP版本、HTTP首部字段等部分构成.<br>
> HTTP响应报文由HTTP版本、状态码、HTTP首部字段3部分构成.

### HTTP首部字段
> 使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的的语言、认证信息等内容.<br>

HTTP首部字段重复了会如何?<br>
由于没有明确的规范,所以根据浏览器不同,会有不同的结果.可能是优先,可能会被覆盖.

#### 4中HTTP首部字段类型
* 通用首部字段
* 请求首部字段
* 响应首部字段
* 实体首部字段

### 通用首部字段
#### Cache-Control及其值
* public 明确表明其他用户也可利用缓存
* private 响应只以特定的用户作为对象
* no-cache 放置从缓存中返回过期资源
* no-store 不进行缓存(不走缓存服务器,直接 客户端-服务器 )
* max-age 客户端: 缓存时间数值比指定时间小,就接收缓存.服务器: 指定时间代表缓存的最长时间.
* min-fresh 要求缓存服务器返回至少还未过指定时间的缓存资源.
* only-if-cached 客户端仅在缓存服务器本地缓存目标资源下才会要求其返回.如果缓存服务器无响应,返回504.
* must-revalidate 代理会向源服务器再次验证即将返回的响应缓存目前是否任然有效.无响应返回504.
* proxy-revalidate 要求缓存服务器在接收到客户端带有该指令的请求返回响应之前,必须再次验证缓存的有效性.
* no-transform 无论是在请求还是响应中,缓存都不能改变实体主体的媒体类型.可防止缓存或代理压缩图片等类似操作.

#### Date
> 表示HTTP报文创建的时间和日期

#### Pragma
no-cache
> 用在客户端,要求中间服务器不返回资源.


#### Connection
> 控制不再转发给代理的首部字段<br>
> 管理持久连接

* 任意字段名 不再转发的首部字段名
* close 服务器端想明确断开连接时
* Keep-Alive 持续连接

# 名词
* FTP File Transfer Protocol 文件传输协议
* DNS Domain Name System 域名系统
* TPC Transmission Control Protocol 传输控制协议
* IP Internet Protocol 网络协议
* UDP User Data Protocol 用户数据报协议
* ARP Address Resolution Protocol 根据IP地址反查MAC地址的协议
* URI Uniform Resource Identifier 统一资源标识符
* SSL Secure Sockets Layer 安全套接层
* TLS Transport Layer Security 传输层安全